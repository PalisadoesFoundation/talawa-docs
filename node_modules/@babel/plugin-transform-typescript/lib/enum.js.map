{"version":3,"names":["ENUMS","WeakMap","transpileEnum","path","t","node","declare","remove","name","id","wrapper","fill","data","enumFill","parent","type","insertAfter","seen","parentPath","isGlobal","isProgram","scope","registerDeclaration","replaceWith","makeVar","set","getBindingIdentifier","Error","isExportDeclaration","getData","setData","kind","variableDeclaration","variableDeclarator","buildEnumWrapper","template","buildStringAssignment","buildNumericAssignment","buildEnumMember","isString","options","enumValues","x","translateEnumValues","assignments","map","memberName","memberValue","isStringLiteral","ENUM","cloneNode","NAME","VALUE","ID","ASSIGNMENTS","ReferencedIdentifier","expr","state","has","hasOwnBinding","memberExpression","skip","enumSelfReferenceVisitor","Map","constValue","lastName","get","memberPath","member","isIdentifier","value","initializerPath","initializer","computeConstantValue","undefined","numericLiteral","assert","stringLiteral","isReferencedIdentifier","traverse","buildCodeFrameError","lastRef","binaryExpression","prevMembers","Set","evaluate","evaluateRef","evalUnaryExpression","evalBinaryExpression","quasis","length","cooked","paths","str","i","isMemberExpression","obj","object","prop","property","computed","bindingIdentifier","bindingInitPath","resolve","add","operator","left","right"],"sources":["../src/enum.ts"],"sourcesContent":["import { template, types as t } from \"@babel/core\";\nimport type { NodePath } from \"@babel/traverse\";\nimport assert from \"assert\";\n\ntype t = typeof t;\n\nconst ENUMS = new WeakMap<t.Identifier, PreviousEnumMembers>();\n\nexport default function transpileEnum(\n  path: NodePath<t.TSEnumDeclaration>,\n  t: t,\n) {\n  const { node } = path;\n\n  if (node.declare) {\n    path.remove();\n    return;\n  }\n\n  const name = node.id.name;\n  const { wrapper: fill, data } = enumFill(path, t, node.id);\n\n  switch (path.parent.type) {\n    case \"BlockStatement\":\n    case \"ExportNamedDeclaration\":\n    case \"Program\": {\n      path.insertAfter(fill);\n      if (seen(path.parentPath)) {\n        path.remove();\n      } else {\n        // todo: Consider exclude program with import/export\n        // && !path.parent.body.some(n => t.isImportDeclaration(n) || t.isExportDeclaration(n));\n        const isGlobal = t.isProgram(path.parent);\n        path.scope.registerDeclaration(\n          path.replaceWith(makeVar(node.id, t, isGlobal ? \"var\" : \"let\"))[0],\n        );\n        ENUMS.set(path.scope.getBindingIdentifier(name), data);\n      }\n      break;\n    }\n\n    default:\n      throw new Error(`Unexpected enum parent '${path.parent.type}`);\n  }\n\n  function seen(parentPath: NodePath<t.Node>): boolean {\n    if (parentPath.isExportDeclaration()) {\n      return seen(parentPath.parentPath);\n    }\n\n    if (parentPath.getData(name)) {\n      return true;\n    } else {\n      parentPath.setData(name, true);\n      return false;\n    }\n  }\n}\n\nfunction makeVar(id: t.Identifier, t: t, kind: \"var\" | \"let\" | \"const\") {\n  return t.variableDeclaration(kind, [t.variableDeclarator(id)]);\n}\n\nconst buildEnumWrapper = template(`\n  (function (ID) {\n    ASSIGNMENTS;\n  })(ID || (ID = {}));\n`);\n\nconst buildStringAssignment = template(`\n  ENUM[\"NAME\"] = VALUE;\n`);\n\nconst buildNumericAssignment = template(`\n  ENUM[ENUM[\"NAME\"] = VALUE] = \"NAME\";\n`);\n\nconst buildEnumMember = (isString: boolean, options: Record<string, unknown>) =>\n  (isString ? buildStringAssignment : buildNumericAssignment)(options);\n\n/**\n * Generates the statement that fills in the variable declared by the enum.\n * `(function (E) { ... assignments ... })(E || (E = {}));`\n */\nfunction enumFill(path: NodePath<t.TSEnumDeclaration>, t: t, id: t.Identifier) {\n  const { enumValues: x, data } = translateEnumValues(path, t);\n  const assignments = x.map(([memberName, memberValue]) =>\n    buildEnumMember(t.isStringLiteral(memberValue), {\n      ENUM: t.cloneNode(id),\n      NAME: memberName,\n      VALUE: memberValue,\n    }),\n  );\n\n  return {\n    wrapper: buildEnumWrapper({\n      ID: t.cloneNode(id),\n      ASSIGNMENTS: assignments,\n    }),\n    data: data,\n  };\n}\n\n/**\n * Maps the name of an enum member to its value.\n * We keep track of the previous enum members so you can write code like:\n *   enum E {\n *     X = 1 << 0,\n *     Y = 1 << 1,\n *     Z = X | Y,\n *   }\n */\ntype PreviousEnumMembers = Map<string, number | string>;\n\ntype EnumSelfReferenceVisitorState = {\n  seen: PreviousEnumMembers;\n  path: NodePath<t.TSEnumDeclaration>;\n  t: t;\n};\n\nfunction ReferencedIdentifier(\n  expr: NodePath<t.Identifier>,\n  state: EnumSelfReferenceVisitorState,\n) {\n  const { seen, path, t } = state;\n  const name = expr.node.name;\n  if (seen.has(name) && !expr.scope.hasOwnBinding(name)) {\n    expr.replaceWith(\n      t.memberExpression(t.cloneNode(path.node.id), t.cloneNode(expr.node)),\n    );\n    expr.skip();\n  }\n}\n\nconst enumSelfReferenceVisitor = {\n  ReferencedIdentifier,\n};\n\nexport function translateEnumValues(path: NodePath<t.TSEnumDeclaration>, t: t) {\n  const seen: PreviousEnumMembers = new Map();\n  // Start at -1 so the first enum member is its increment, 0.\n  let constValue: number | string | undefined = -1;\n  let lastName: string;\n\n  return {\n    data: seen,\n    enumValues: path.get(\"members\").map(memberPath => {\n      const member = memberPath.node;\n      const name = t.isIdentifier(member.id) ? member.id.name : member.id.value;\n      const initializerPath = memberPath.get(\"initializer\");\n      const initializer = member.initializer;\n      let value: t.Expression;\n      if (initializer) {\n        constValue = computeConstantValue(initializerPath, seen);\n        if (constValue !== undefined) {\n          seen.set(name, constValue);\n          if (typeof constValue === \"number\") {\n            value = t.numericLiteral(constValue);\n          } else {\n            assert(typeof constValue === \"string\");\n            value = t.stringLiteral(constValue);\n          }\n        } else {\n          if (initializerPath.isReferencedIdentifier()) {\n            ReferencedIdentifier(initializerPath, {\n              t,\n              seen,\n              path,\n            });\n          } else {\n            initializerPath.traverse(enumSelfReferenceVisitor, {\n              t,\n              seen,\n              path,\n            });\n          }\n\n          value = initializerPath.node;\n          seen.set(name, undefined);\n        }\n      } else if (typeof constValue === \"number\") {\n        constValue += 1;\n        value = t.numericLiteral(constValue);\n        seen.set(name, constValue);\n      } else if (typeof constValue === \"string\") {\n        throw path.buildCodeFrameError(\"Enum member must have initializer.\");\n      } else {\n        // create dynamic initializer: 1 + ENUM[\"PREVIOUS\"]\n        const lastRef = t.memberExpression(\n          t.cloneNode(path.node.id),\n          t.stringLiteral(lastName),\n          true,\n        );\n        value = t.binaryExpression(\"+\", t.numericLiteral(1), lastRef);\n        seen.set(name, undefined);\n      }\n\n      lastName = name;\n      return [name, value];\n    }) as Array<[name: string, value: t.Expression]>,\n  };\n}\n\n// Based on the TypeScript repository's `computeConstantValue` in `checker.ts`.\nfunction computeConstantValue(\n  path: NodePath,\n  prevMembers?: PreviousEnumMembers,\n  seen: Set<t.Identifier> = new Set(),\n): number | string | undefined {\n  return evaluate(path);\n\n  function evaluate(path: NodePath): number | string | undefined {\n    const expr = path.node;\n    switch (expr.type) {\n      case \"MemberExpression\":\n        return evaluateRef(path, prevMembers, seen);\n      case \"StringLiteral\":\n        return expr.value;\n      case \"UnaryExpression\":\n        return evalUnaryExpression(path as NodePath<t.UnaryExpression>);\n      case \"BinaryExpression\":\n        return evalBinaryExpression(path as NodePath<t.BinaryExpression>);\n      case \"NumericLiteral\":\n        return expr.value;\n      case \"ParenthesizedExpression\":\n        return evaluate(path.get(\"expression\"));\n      case \"Identifier\":\n        return evaluateRef(path, prevMembers, seen);\n      case \"TemplateLiteral\": {\n        if (expr.quasis.length === 1) {\n          return expr.quasis[0].value.cooked;\n        }\n\n        const paths = (path as NodePath<t.TemplateLiteral>).get(\"expressions\");\n        const quasis = expr.quasis;\n        let str = \"\";\n\n        for (let i = 0; i < quasis.length; i++) {\n          str += quasis[i].value.cooked;\n\n          if (i + 1 < quasis.length) {\n            const value = evaluateRef(paths[i], prevMembers, seen);\n            if (value === undefined) return undefined;\n            str += value;\n          }\n        }\n        return str;\n      }\n      default:\n        return undefined;\n    }\n  }\n\n  function evaluateRef(\n    path: NodePath,\n    prevMembers: PreviousEnumMembers,\n    seen: Set<t.Identifier>,\n  ): number | string | undefined {\n    if (path.isMemberExpression()) {\n      const expr = path.node;\n\n      const obj = expr.object;\n      const prop = expr.property;\n      if (\n        !t.isIdentifier(obj) ||\n        (expr.computed ? !t.isStringLiteral(prop) : !t.isIdentifier(prop))\n      ) {\n        return;\n      }\n      const bindingIdentifier = path.scope.getBindingIdentifier(obj.name);\n      const data = ENUMS.get(bindingIdentifier);\n      if (!data) return;\n      // @ts-expect-error checked above\n      return data.get(prop.computed ? prop.value : prop.name);\n    } else if (path.isIdentifier()) {\n      const name = path.node.name;\n\n      let value = prevMembers?.get(name);\n      if (value !== undefined) {\n        return value;\n      }\n\n      if (seen.has(path.node)) return;\n\n      const bindingInitPath = path.resolve(); // It only resolves constant bindings\n      if (bindingInitPath) {\n        seen.add(path.node);\n\n        value = computeConstantValue(bindingInitPath, undefined, seen);\n        prevMembers?.set(name, value);\n        return value;\n      }\n    }\n  }\n\n  function evalUnaryExpression(\n    path: NodePath<t.UnaryExpression>,\n  ): number | string | undefined {\n    const value = evaluate(path.get(\"argument\"));\n    if (value === undefined) {\n      return undefined;\n    }\n\n    switch (path.node.operator) {\n      case \"+\":\n        return value;\n      case \"-\":\n        return -value;\n      case \"~\":\n        return ~value;\n      default:\n        return undefined;\n    }\n  }\n\n  function evalBinaryExpression(\n    path: NodePath<t.BinaryExpression>,\n  ): number | string | undefined {\n    const left = evaluate(path.get(\"left\")) as any;\n    if (left === undefined) {\n      return undefined;\n    }\n    const right = evaluate(path.get(\"right\")) as any;\n    if (right === undefined) {\n      return undefined;\n    }\n\n    switch (path.node.operator) {\n      case \"|\":\n        return left | right;\n      case \"&\":\n        return left & right;\n      case \">>\":\n        return left >> right;\n      case \">>>\":\n        return left >>> right;\n      case \"<<\":\n        return left << right;\n      case \"^\":\n        return left ^ right;\n      case \"*\":\n        return left * right;\n      case \"/\":\n        return left / right;\n      case \"+\":\n        return left + right;\n      case \"-\":\n        return left - right;\n      case \"%\":\n        return left % right;\n      case \"**\":\n        return left ** right;\n      default:\n        return undefined;\n    }\n  }\n}\n"],"mappings":";;;;;;;AAAA;AAEA;AAIA,MAAMA,KAAK,GAAG,IAAIC,OAAO,EAAqC;AAE/C,SAASC,aAAa,CACnCC,IAAmC,EACnCC,CAAI,EACJ;EACA,MAAM;IAAEC;EAAK,CAAC,GAAGF,IAAI;EAErB,IAAIE,IAAI,CAACC,OAAO,EAAE;IAChBH,IAAI,CAACI,MAAM,EAAE;IACb;EACF;EAEA,MAAMC,IAAI,GAAGH,IAAI,CAACI,EAAE,CAACD,IAAI;EACzB,MAAM;IAAEE,OAAO,EAAEC,IAAI;IAAEC;EAAK,CAAC,GAAGC,QAAQ,CAACV,IAAI,EAAEC,CAAC,EAAEC,IAAI,CAACI,EAAE,CAAC;EAE1D,QAAQN,IAAI,CAACW,MAAM,CAACC,IAAI;IACtB,KAAK,gBAAgB;IACrB,KAAK,wBAAwB;IAC7B,KAAK,SAAS;MAAE;QACdZ,IAAI,CAACa,WAAW,CAACL,IAAI,CAAC;QACtB,IAAIM,IAAI,CAACd,IAAI,CAACe,UAAU,CAAC,EAAE;UACzBf,IAAI,CAACI,MAAM,EAAE;QACf,CAAC,MAAM;UAGL,MAAMY,QAAQ,GAAGf,CAAC,CAACgB,SAAS,CAACjB,IAAI,CAACW,MAAM,CAAC;UACzCX,IAAI,CAACkB,KAAK,CAACC,mBAAmB,CAC5BnB,IAAI,CAACoB,WAAW,CAACC,OAAO,CAACnB,IAAI,CAACI,EAAE,EAAEL,CAAC,EAAEe,QAAQ,GAAG,KAAK,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CACnE;UACDnB,KAAK,CAACyB,GAAG,CAACtB,IAAI,CAACkB,KAAK,CAACK,oBAAoB,CAAClB,IAAI,CAAC,EAAEI,IAAI,CAAC;QACxD;QACA;MACF;IAEA;MACE,MAAM,IAAIe,KAAK,CAAE,2BAA0BxB,IAAI,CAACW,MAAM,CAACC,IAAK,EAAC,CAAC;EAAC;EAGnE,SAASE,IAAI,CAACC,UAA4B,EAAW;IACnD,IAAIA,UAAU,CAACU,mBAAmB,EAAE,EAAE;MACpC,OAAOX,IAAI,CAACC,UAAU,CAACA,UAAU,CAAC;IACpC;IAEA,IAAIA,UAAU,CAACW,OAAO,CAACrB,IAAI,CAAC,EAAE;MAC5B,OAAO,IAAI;IACb,CAAC,MAAM;MACLU,UAAU,CAACY,OAAO,CAACtB,IAAI,EAAE,IAAI,CAAC;MAC9B,OAAO,KAAK;IACd;EACF;AACF;AAEA,SAASgB,OAAO,CAACf,EAAgB,EAAEL,CAAI,EAAE2B,IAA6B,EAAE;EACtE,OAAO3B,CAAC,CAAC4B,mBAAmB,CAACD,IAAI,EAAE,CAAC3B,CAAC,CAAC6B,kBAAkB,CAACxB,EAAE,CAAC,CAAC,CAAC;AAChE;AAEA,MAAMyB,gBAAgB,GAAG,IAAAC,cAAQ,EAAE;AACnC;AACA;AACA;AACA,CAAC,CAAC;AAEF,MAAMC,qBAAqB,GAAG,IAAAD,cAAQ,EAAE;AACxC;AACA,CAAC,CAAC;AAEF,MAAME,sBAAsB,GAAG,IAAAF,cAAQ,EAAE;AACzC;AACA,CAAC,CAAC;AAEF,MAAMG,eAAe,GAAG,CAACC,QAAiB,EAAEC,OAAgC,KAC1E,CAACD,QAAQ,GAAGH,qBAAqB,GAAGC,sBAAsB,EAAEG,OAAO,CAAC;AAMtE,SAAS3B,QAAQ,CAACV,IAAmC,EAAEC,CAAI,EAAEK,EAAgB,EAAE;EAC7E,MAAM;IAAEgC,UAAU,EAAEC,CAAC;IAAE9B;EAAK,CAAC,GAAG+B,mBAAmB,CAACxC,IAAI,EAAEC,CAAC,CAAC;EAC5D,MAAMwC,WAAW,GAAGF,CAAC,CAACG,GAAG,CAAC,CAAC,CAACC,UAAU,EAAEC,WAAW,CAAC,KAClDT,eAAe,CAAClC,CAAC,CAAC4C,eAAe,CAACD,WAAW,CAAC,EAAE;IAC9CE,IAAI,EAAE7C,CAAC,CAAC8C,SAAS,CAACzC,EAAE,CAAC;IACrB0C,IAAI,EAAEL,UAAU;IAChBM,KAAK,EAAEL;EACT,CAAC,CAAC,CACH;EAED,OAAO;IACLrC,OAAO,EAAEwB,gBAAgB,CAAC;MACxBmB,EAAE,EAAEjD,CAAC,CAAC8C,SAAS,CAACzC,EAAE,CAAC;MACnB6C,WAAW,EAAEV;IACf,CAAC,CAAC;IACFhC,IAAI,EAAEA;EACR,CAAC;AACH;AAmBA,SAAS2C,oBAAoB,CAC3BC,IAA4B,EAC5BC,KAAoC,EACpC;EACA,MAAM;IAAExC,IAAI;IAAEd,IAAI;IAAEC;EAAE,CAAC,GAAGqD,KAAK;EAC/B,MAAMjD,IAAI,GAAGgD,IAAI,CAACnD,IAAI,CAACG,IAAI;EAC3B,IAAIS,IAAI,CAACyC,GAAG,CAAClD,IAAI,CAAC,IAAI,CAACgD,IAAI,CAACnC,KAAK,CAACsC,aAAa,CAACnD,IAAI,CAAC,EAAE;IACrDgD,IAAI,CAACjC,WAAW,CACdnB,CAAC,CAACwD,gBAAgB,CAACxD,CAAC,CAAC8C,SAAS,CAAC/C,IAAI,CAACE,IAAI,CAACI,EAAE,CAAC,EAAEL,CAAC,CAAC8C,SAAS,CAACM,IAAI,CAACnD,IAAI,CAAC,CAAC,CACtE;IACDmD,IAAI,CAACK,IAAI,EAAE;EACb;AACF;AAEA,MAAMC,wBAAwB,GAAG;EAC/BP;AACF,CAAC;AAEM,SAASZ,mBAAmB,CAACxC,IAAmC,EAAEC,CAAI,EAAE;EAC7E,MAAMa,IAAyB,GAAG,IAAI8C,GAAG,EAAE;EAE3C,IAAIC,UAAuC,GAAG,CAAC,CAAC;EAChD,IAAIC,QAAgB;EAEpB,OAAO;IACLrD,IAAI,EAAEK,IAAI;IACVwB,UAAU,EAAEtC,IAAI,CAAC+D,GAAG,CAAC,SAAS,CAAC,CAACrB,GAAG,CAACsB,UAAU,IAAI;MAChD,MAAMC,MAAM,GAAGD,UAAU,CAAC9D,IAAI;MAC9B,MAAMG,IAAI,GAAGJ,CAAC,CAACiE,YAAY,CAACD,MAAM,CAAC3D,EAAE,CAAC,GAAG2D,MAAM,CAAC3D,EAAE,CAACD,IAAI,GAAG4D,MAAM,CAAC3D,EAAE,CAAC6D,KAAK;MACzE,MAAMC,eAAe,GAAGJ,UAAU,CAACD,GAAG,CAAC,aAAa,CAAC;MACrD,MAAMM,WAAW,GAAGJ,MAAM,CAACI,WAAW;MACtC,IAAIF,KAAmB;MACvB,IAAIE,WAAW,EAAE;QACfR,UAAU,GAAGS,oBAAoB,CAACF,eAAe,EAAEtD,IAAI,CAAC;QACxD,IAAI+C,UAAU,KAAKU,SAAS,EAAE;UAC5BzD,IAAI,CAACQ,GAAG,CAACjB,IAAI,EAAEwD,UAAU,CAAC;UAC1B,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;YAClCM,KAAK,GAAGlE,CAAC,CAACuE,cAAc,CAACX,UAAU,CAAC;UACtC,CAAC,MAAM;YACLY,OAAM,CAAC,OAAOZ,UAAU,KAAK,QAAQ,CAAC;YACtCM,KAAK,GAAGlE,CAAC,CAACyE,aAAa,CAACb,UAAU,CAAC;UACrC;QACF,CAAC,MAAM;UACL,IAAIO,eAAe,CAACO,sBAAsB,EAAE,EAAE;YAC5CvB,oBAAoB,CAACgB,eAAe,EAAE;cACpCnE,CAAC;cACDa,IAAI;cACJd;YACF,CAAC,CAAC;UACJ,CAAC,MAAM;YACLoE,eAAe,CAACQ,QAAQ,CAACjB,wBAAwB,EAAE;cACjD1D,CAAC;cACDa,IAAI;cACJd;YACF,CAAC,CAAC;UACJ;UAEAmE,KAAK,GAAGC,eAAe,CAAClE,IAAI;UAC5BY,IAAI,CAACQ,GAAG,CAACjB,IAAI,EAAEkE,SAAS,CAAC;QAC3B;MACF,CAAC,MAAM,IAAI,OAAOV,UAAU,KAAK,QAAQ,EAAE;QACzCA,UAAU,IAAI,CAAC;QACfM,KAAK,GAAGlE,CAAC,CAACuE,cAAc,CAACX,UAAU,CAAC;QACpC/C,IAAI,CAACQ,GAAG,CAACjB,IAAI,EAAEwD,UAAU,CAAC;MAC5B,CAAC,MAAM,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;QACzC,MAAM7D,IAAI,CAAC6E,mBAAmB,CAAC,oCAAoC,CAAC;MACtE,CAAC,MAAM;QAEL,MAAMC,OAAO,GAAG7E,CAAC,CAACwD,gBAAgB,CAChCxD,CAAC,CAAC8C,SAAS,CAAC/C,IAAI,CAACE,IAAI,CAACI,EAAE,CAAC,EACzBL,CAAC,CAACyE,aAAa,CAACZ,QAAQ,CAAC,EACzB,IAAI,CACL;QACDK,KAAK,GAAGlE,CAAC,CAAC8E,gBAAgB,CAAC,GAAG,EAAE9E,CAAC,CAACuE,cAAc,CAAC,CAAC,CAAC,EAAEM,OAAO,CAAC;QAC7DhE,IAAI,CAACQ,GAAG,CAACjB,IAAI,EAAEkE,SAAS,CAAC;MAC3B;MAEAT,QAAQ,GAAGzD,IAAI;MACf,OAAO,CAACA,IAAI,EAAE8D,KAAK,CAAC;IACtB,CAAC;EACH,CAAC;AACH;AAGA,SAASG,oBAAoB,CAC3BtE,IAAc,EACdgF,WAAiC,EACjClE,IAAuB,GAAG,IAAImE,GAAG,EAAE,EACN;EAC7B,OAAOC,QAAQ,CAAClF,IAAI,CAAC;EAErB,SAASkF,QAAQ,CAAClF,IAAc,EAA+B;IAC7D,MAAMqD,IAAI,GAAGrD,IAAI,CAACE,IAAI;IACtB,QAAQmD,IAAI,CAACzC,IAAI;MACf,KAAK,kBAAkB;QACrB,OAAOuE,WAAW,CAACnF,IAAI,EAAEgF,WAAW,EAAElE,IAAI,CAAC;MAC7C,KAAK,eAAe;QAClB,OAAOuC,IAAI,CAACc,KAAK;MACnB,KAAK,iBAAiB;QACpB,OAAOiB,mBAAmB,CAACpF,IAAI,CAAgC;MACjE,KAAK,kBAAkB;QACrB,OAAOqF,oBAAoB,CAACrF,IAAI,CAAiC;MACnE,KAAK,gBAAgB;QACnB,OAAOqD,IAAI,CAACc,KAAK;MACnB,KAAK,yBAAyB;QAC5B,OAAOe,QAAQ,CAAClF,IAAI,CAAC+D,GAAG,CAAC,YAAY,CAAC,CAAC;MACzC,KAAK,YAAY;QACf,OAAOoB,WAAW,CAACnF,IAAI,EAAEgF,WAAW,EAAElE,IAAI,CAAC;MAC7C,KAAK,iBAAiB;QAAE;UACtB,IAAIuC,IAAI,CAACiC,MAAM,CAACC,MAAM,KAAK,CAAC,EAAE;YAC5B,OAAOlC,IAAI,CAACiC,MAAM,CAAC,CAAC,CAAC,CAACnB,KAAK,CAACqB,MAAM;UACpC;UAEA,MAAMC,KAAK,GAAIzF,IAAI,CAAiC+D,GAAG,CAAC,aAAa,CAAC;UACtE,MAAMuB,MAAM,GAAGjC,IAAI,CAACiC,MAAM;UAC1B,IAAII,GAAG,GAAG,EAAE;UAEZ,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,MAAM,CAACC,MAAM,EAAEI,CAAC,EAAE,EAAE;YACtCD,GAAG,IAAIJ,MAAM,CAACK,CAAC,CAAC,CAACxB,KAAK,CAACqB,MAAM;YAE7B,IAAIG,CAAC,GAAG,CAAC,GAAGL,MAAM,CAACC,MAAM,EAAE;cACzB,MAAMpB,KAAK,GAAGgB,WAAW,CAACM,KAAK,CAACE,CAAC,CAAC,EAAEX,WAAW,EAAElE,IAAI,CAAC;cACtD,IAAIqD,KAAK,KAAKI,SAAS,EAAE,OAAOA,SAAS;cACzCmB,GAAG,IAAIvB,KAAK;YACd;UACF;UACA,OAAOuB,GAAG;QACZ;MACA;QACE,OAAOnB,SAAS;IAAC;EAEvB;EAEA,SAASY,WAAW,CAClBnF,IAAc,EACdgF,WAAgC,EAChClE,IAAuB,EACM;IAC7B,IAAId,IAAI,CAAC4F,kBAAkB,EAAE,EAAE;MAC7B,MAAMvC,IAAI,GAAGrD,IAAI,CAACE,IAAI;MAEtB,MAAM2F,GAAG,GAAGxC,IAAI,CAACyC,MAAM;MACvB,MAAMC,IAAI,GAAG1C,IAAI,CAAC2C,QAAQ;MAC1B,IACE,CAAC/F,WAAC,CAACiE,YAAY,CAAC2B,GAAG,CAAC,KACnBxC,IAAI,CAAC4C,QAAQ,GAAG,CAAChG,WAAC,CAAC4C,eAAe,CAACkD,IAAI,CAAC,GAAG,CAAC9F,WAAC,CAACiE,YAAY,CAAC6B,IAAI,CAAC,CAAC,EAClE;QACA;MACF;MACA,MAAMG,iBAAiB,GAAGlG,IAAI,CAACkB,KAAK,CAACK,oBAAoB,CAACsE,GAAG,CAACxF,IAAI,CAAC;MACnE,MAAMI,IAAI,GAAGZ,KAAK,CAACkE,GAAG,CAACmC,iBAAiB,CAAC;MACzC,IAAI,CAACzF,IAAI,EAAE;MAEX,OAAOA,IAAI,CAACsD,GAAG,CAACgC,IAAI,CAACE,QAAQ,GAAGF,IAAI,CAAC5B,KAAK,GAAG4B,IAAI,CAAC1F,IAAI,CAAC;IACzD,CAAC,MAAM,IAAIL,IAAI,CAACkE,YAAY,EAAE,EAAE;MAC9B,MAAM7D,IAAI,GAAGL,IAAI,CAACE,IAAI,CAACG,IAAI;MAE3B,IAAI8D,KAAK,GAAGa,WAAW,oBAAXA,WAAW,CAAEjB,GAAG,CAAC1D,IAAI,CAAC;MAClC,IAAI8D,KAAK,KAAKI,SAAS,EAAE;QACvB,OAAOJ,KAAK;MACd;MAEA,IAAIrD,IAAI,CAACyC,GAAG,CAACvD,IAAI,CAACE,IAAI,CAAC,EAAE;MAEzB,MAAMiG,eAAe,GAAGnG,IAAI,CAACoG,OAAO,EAAE;MACtC,IAAID,eAAe,EAAE;QACnBrF,IAAI,CAACuF,GAAG,CAACrG,IAAI,CAACE,IAAI,CAAC;QAEnBiE,KAAK,GAAGG,oBAAoB,CAAC6B,eAAe,EAAE5B,SAAS,EAAEzD,IAAI,CAAC;QAC9DkE,WAAW,oBAAXA,WAAW,CAAE1D,GAAG,CAACjB,IAAI,EAAE8D,KAAK,CAAC;QAC7B,OAAOA,KAAK;MACd;IACF;EACF;EAEA,SAASiB,mBAAmB,CAC1BpF,IAAiC,EACJ;IAC7B,MAAMmE,KAAK,GAAGe,QAAQ,CAAClF,IAAI,CAAC+D,GAAG,CAAC,UAAU,CAAC,CAAC;IAC5C,IAAII,KAAK,KAAKI,SAAS,EAAE;MACvB,OAAOA,SAAS;IAClB;IAEA,QAAQvE,IAAI,CAACE,IAAI,CAACoG,QAAQ;MACxB,KAAK,GAAG;QACN,OAAOnC,KAAK;MACd,KAAK,GAAG;QACN,OAAO,CAACA,KAAK;MACf,KAAK,GAAG;QACN,OAAO,CAACA,KAAK;MACf;QACE,OAAOI,SAAS;IAAC;EAEvB;EAEA,SAASc,oBAAoB,CAC3BrF,IAAkC,EACL;IAC7B,MAAMuG,IAAI,GAAGrB,QAAQ,CAAClF,IAAI,CAAC+D,GAAG,CAAC,MAAM,CAAC,CAAQ;IAC9C,IAAIwC,IAAI,KAAKhC,SAAS,EAAE;MACtB,OAAOA,SAAS;IAClB;IACA,MAAMiC,KAAK,GAAGtB,QAAQ,CAAClF,IAAI,CAAC+D,GAAG,CAAC,OAAO,CAAC,CAAQ;IAChD,IAAIyC,KAAK,KAAKjC,SAAS,EAAE;MACvB,OAAOA,SAAS;IAClB;IAEA,QAAQvE,IAAI,CAACE,IAAI,CAACoG,QAAQ;MACxB,KAAK,GAAG;QACN,OAAOC,IAAI,GAAGC,KAAK;MACrB,KAAK,GAAG;QACN,OAAOD,IAAI,GAAGC,KAAK;MACrB,KAAK,IAAI;QACP,OAAOD,IAAI,IAAIC,KAAK;MACtB,KAAK,KAAK;QACR,OAAOD,IAAI,KAAKC,KAAK;MACvB,KAAK,IAAI;QACP,OAAOD,IAAI,IAAIC,KAAK;MACtB,KAAK,GAAG;QACN,OAAOD,IAAI,GAAGC,KAAK;MACrB,KAAK,GAAG;QACN,OAAOD,IAAI,GAAGC,KAAK;MACrB,KAAK,GAAG;QACN,OAAOD,IAAI,GAAGC,KAAK;MACrB,KAAK,GAAG;QACN,OAAOD,IAAI,GAAGC,KAAK;MACrB,KAAK,GAAG;QACN,OAAOD,IAAI,GAAGC,KAAK;MACrB,KAAK,GAAG;QACN,OAAOD,IAAI,GAAGC,KAAK;MACrB,KAAK,IAAI;QACP,gBAAOD,IAAI,EAAIC,KAAK;MACtB;QACE,OAAOjC,SAAS;IAAC;EAEvB;AACF"}