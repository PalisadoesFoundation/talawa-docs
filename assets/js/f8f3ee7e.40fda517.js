"use strict";(self.webpackChunktalawa_docs=self.webpackChunktalawa_docs||[]).push([[23305],{86780:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>d,contentTitle:()=>c,default:()=>o,frontMatter:()=>i,metadata:()=>l,toc:()=>a});var t=r(85893),s=r(11151);const i={id:"recurring-events",title:"Recurring Events"},c=void 0,l={id:"functionalities/recurring-events",title:"Recurring Events",description:"Goals",source:"@site/docs/functionalities/recurring-events.md",sourceDirName:"functionalities",slug:"/functionalities/recurring-events",permalink:"/docs/functionalities/recurring-events",draft:!1,unlisted:!1,editUrl:"https://github.com/PalisadoesFoundation/talawa-docs/edit/develop/docs/functionalities/recurring-events.md",tags:[],version:"current",frontMatter:{id:"recurring-events",title:"Recurring Events"},sidebar:"docs",previous:{title:"Core Functionalities",permalink:"/docs/functionalities/core-functionalities"},next:{title:"Desired Features",permalink:"/docs/category/desired-features"}},d={},a=[{value:"Goals",id:"goals",level:2},{value:"Interfaces",id:"interfaces",level:2},{value:"Approach",id:"approach",level:2},{value:"Creating recurring events",id:"creating-recurring-events",level:3},{value:"Updating recurring events",id:"updating-recurring-events",level:3},{value:"Deleting recurring events",id:"deleting-recurring-events",level:3},{value:"Querying events",id:"querying-events",level:3},{value:"Handling exception instances",id:"handling-exception-instances",level:3},{value:"Historical Records",id:"historical-records",level:3},{value:"References",id:"references",level:2},{value:"rrule",id:"rrule",level:3},{value:"RecurrenceRule",id:"recurrencerule",level:3},{value:"BaseRecurringEvent",id:"baserecurringevent",level:3},{value:"Recurring Event Instance",id:"recurring-event-instance",level:3},{value:"Recurring Event Exception Instance",id:"recurring-event-exception-instance",level:3}];function h(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h2,{id:"goals",children:"Goals"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"What do we need?"})})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:"The functionalities for creating recurring events, with custom recurrence patterns, like the top calendar apps out there."}),"\n",(0,t.jsxs)(n.li,{children:["The functionalities for updating / deleting:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"a single instance"}),"\n",(0,t.jsx)(n.li,{children:"this and following instances"}),"\n",(0,t.jsxs)(n.li,{children:["all instances ",(0,t.jsx)("br",{}),"\nof a recurring event"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.li,{children:"A way to track the historical records of a recurring event."}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"interfaces",children:"Interfaces"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"  interface InterfaceEvent {\n    // ...existing event fields\n    isBaseRecurringEvent: boolean;\n    recurrenceRuleId: ObjectId;\n    baseRecurringEventId: ObjectId;\n    isRecurringEventException: boolean;\n  }\n\n  interface InterfaceRecurrenceRule {\n    recurrenceStartDate: Date;\n    recurrenceEndDate: Date;\n    recurrenceRuleString: string;\n    // ...recurrence specific properties (frequency, count, interval, etc.)\n    latestInstanceDate: Date;\n    baseRecurringEventId: ObjectId;\n  }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["The purpose and need for each of the fields and Interfaces will be explained in the ",(0,t.jsx)(n.strong,{children:"Approach"})," as their necessity arises."]}),"\n",(0,t.jsx)(n.h2,{id:"approach",children:"Approach"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["We are using the ",(0,t.jsx)(n.code,{children:"rrule"})," libary and following the dynamic generation approach."]}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"creating-recurring-events",children:"Creating recurring events"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Create event input:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["For recurring events, along with the general ",(0,t.jsx)(n.code,{children:"EventInput"}),", there would also be a ",(0,t.jsx)(n.code,{children:"RecurrenceRuleInput"})," (which, if not provided, would default to infinite weekly recurrence), containing the recurrence pattern."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["After getting the input, we'd follow these steps (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/createEventHelpers/createRecurringEvent.ts",children:"createRecurringEvent.ts"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Generate a ",(0,t.jsx)(n.code,{children:"recurrenceRuleString"})," from our ",(0,t.jsx)(n.code,{children:"RecurrenceRuleInput"})," that would specify our recurrence rule in ",(0,t.jsx)(n.code,{children:"rrule"})," string format (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/recurringEventHelpers/generateRecurrenceRuleString.ts",children:"generateRecurrenceRuleString.ts"}),")."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Create a ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"})," that would just be like creating a normal event with ",(0,t.jsx)(n.code,{children:"isBaseRecurringEvent: true"}),", let's name it's ",(0,t.jsx)(n.code,{children:"_id"})," to be ",(0,t.jsx)(n.code,{children:"baseRecurringEventId"})," (This is what we will use as the base event for generating instances.)"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Get the dates of recurrence using the ",(0,t.jsx)(n.code,{children:"rrule"})," library (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/recurringEventHelpers/getRecurringInstanceDates.ts",children:"getRecurringInstanceDates.ts"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Fix a ",(0,t.jsx)(n.code,{children:"limitEndDate"}),", say ",(0,t.jsx)(n.code,{children:"X"})," years ahead from the recurrence start date (depending on the recurrence frequency), that would help determine the date upto which we will generate instances in the ",(0,t.jsx)(n.code,{children:"createEvent"})," mutation. We'll leave the rest for dynamic generation during the events ",(0,t.jsx)(n.code,{children:"query"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"recurrenceEndDate: null"})," or ",(0,t.jsx)(n.code,{children:"recurrenceEndDate > limitEndDate"}),", we'd generate dates upto ",(0,t.jsx)(n.code,{children:"limitEndDate"}),", and leave the rest for dynamic generation during queries."]}),"\n",(0,t.jsxs)(n.li,{children:["If ",(0,t.jsx)(n.code,{children:"recurrenceEndDate < limitEndDate"}),", then we just generate all the dates of recurrence."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Both ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," & ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"})," will contain these ",(0,t.jsx)(n.code,{children:"recurrenceStartDate"})," and the ",(0,t.jsx)(n.code,{children:"recurrenceEndDate"})," values as provided in the ",(0,t.jsx)(n.code,{children:"RecurrenceRuleInput"}),"."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"EventInput"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"startDate"}),": Start Date of that event instance."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"endDate"}),": End Date of that event instance."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["These dates will be selected from the create event modal, and would specify the event duration in days.\ni.e. If for an event, we select ",(0,t.jsx)(n.code,{children:'startDate: "2024-18-04"'})," & ",(0,t.jsx)(n.code,{children:'endDate: "2024-20-04"'}),", then all of the generated instances of that recurring event will\nhave that two day gap between their start and end dates."]})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"RecurrenceRuleInput"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"recurrenceStartDate"}),": Start Date of recurrence. It will be the same as the ",(0,t.jsx)(n.code,{children:"startDate"})," we select for the first instance."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"recurrenceEndDate"}),": End Date of recurrence. By default, it will be null, i.e.\ndefault infinite recurrence. It can be changed through the custom recurrence modal."]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Only one of ",(0,t.jsx)(n.code,{children:"recurrenceEndDate"})," or ",(0,t.jsx)(n.code,{children:"count"})," will exist. i.e. if we select a specific end date of recurrence, ",(0,t.jsx)(n.code,{children:"count"})," will be null, if we chose a specific count istead, then ",(0,t.jsx)(n.code,{children:"recurrenceEndDate"})," will be null."]})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Create a ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," document that would contain the ",(0,t.jsx)(n.code,{children:"recurrenceRuleString"})," and the recurrence fields for easy understanding and debugging, let's name this document's ",(0,t.jsx)(n.code,{children:"_id"})," to be ",(0,t.jsx)(n.code,{children:"recurranceRuleId"}),". Set it's ",(0,t.jsx)(n.code,{children:"latestInstanceDate"})," to be the last date generated during this mutation."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Generate the recurring event instances, make associations (attendees, user), and cache them (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/recurringEventHelpers/generateRecurringEventInstances.ts",children:"generateRecurringEventInstances.ts"}),")."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["All of the instances (Event documents) we created in the previous step will be based on the ",(0,t.jsx)(n.code,{children:"EventInput"})," data, and the remaining instances (if any) will be generated during queries, based on the ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"})," document that we created above."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["All of the instances would have their ",(0,t.jsx)(n.em,{children:"recurrenceRuleId"})," field set to ",(0,t.jsx)(n.code,{children:"recurranceRuleId"}),", and the ",(0,t.jsx)(n.em,{children:"BaseRecurringEventId"})," set to ",(0,t.jsx)(n.code,{children:"baseRecurringEventId"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"updating-recurring-events",children:"Updating recurring events"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["For single events made recurring (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/updateEventHelpers/updateSingleEvent.ts",children:"updateSingleEvent.ts"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Get the data used to generate the instances (i.e. the current data of the event, and the latest data from the update input)."}),"\n",(0,t.jsx)(n.li,{children:"Follow the steps for creating a recurring event."}),"\n",(0,t.jsx)(n.li,{children:"Delete the current event and its associations, as new ones would be made while generating new instances."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["While updating a recurring event, we will provide options to update ",(0,t.jsx)(n.code,{children:"thisInstance"}),", ",(0,t.jsx)(n.code,{children:"thisAndFollowingInstances"}),", & ",(0,t.jsx)(n.code,{children:"allInstances"})," of the recurring event (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/updateEventHelpers/updateRecurringEvent.ts",children:"updateRecurringEvent.ts"}),")."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Appropriate update options will be provided based on whether the ",(0,t.jsx)(n.code,{children:"recurrenceRule"}),", or the ",(0,t.jsx)(n.code,{children:"instanceDuration"})," (difference between event's start and end dates), or both have changed."]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If neither the ",(0,t.jsx)(n.code,{children:"recurrenceRule"})," nor the ",(0,t.jsx)(n.code,{children:"instanceDuration"})," have changed, then we will provide all three update options."]}),"\n",(0,t.jsxs)(n.li,{children:["If the ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," has changed, then we will not provide the option to update ",(0,t.jsx)(n.code,{children:"thisInstance"}),", i.e. only ",(0,t.jsx)(n.code,{children:"thisAndFollowingInstances"})," & ",(0,t.jsx)(n.code,{children:"allInstances"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If the ",(0,t.jsx)(n.code,{children:"instanceDuration"})," has changed, then we will not provide the option to update ",(0,t.jsx)(n.code,{children:"allInstances"}),", i.e. only ",(0,t.jsx)(n.code,{children:"thisInstance"})," & ",(0,t.jsx)(n.code,{children:"thisAndFollowingInstances"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"Update Options:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"thisInstance"}),": Just make a regular update on this event instance (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/updateEventHelpers/updateThisInstance.ts",children:"updateThisInstance.ts"}),")"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsx)(n.p,{children:"Updating a single recurring event instance will make it an exception instance."})}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"thisAndFollowingInstances"})," or ",(0,t.jsx)(n.code,{children:"allInstances"})," (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/updateEventHelpers/updateRecurringEventInstances.ts",children:"updateRecurringEventInstances.ts"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["If neither of the ",(0,t.jsx)(n.code,{children:"recurrenceRule"})," or the ",(0,t.jsx)(n.code,{children:"instanceDuration"})," has changed, we will just perform a bulk update on the instances."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["If either one of the ",(0,t.jsx)(n.code,{children:"recurrenceRule"})," or the ",(0,t.jsx)(n.code,{children:"instanceDuration"})," has changed, we will delete the current series, remove their associations and generate a new one:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Delete instances conforming to the old ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," (We can do this because we are generating events dynamically, i.e. we are only creating instances upto a certain date, so not many documents have to be deleted)."]}),"\n",(0,t.jsxs)(n.li,{children:["Find the latest instance that was following the old ",(0,t.jsx)(n.code,{children:"RecurrenceRule"}),", say ",(0,t.jsx)(n.code,{children:"latestInstance"}),", and set the ",(0,t.jsx)(n.code,{children:"latestInstanceDate"})," and the ",(0,t.jsx)(n.code,{children:"recurrenceEndDate"})," of the old ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," to be this ",(0,t.jsx)(n.code,{children:"latestInstance"}),"'s ",(0,t.jsx)(n.code,{children:"startDate"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Generate new instances based on the new ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," and the updated event data."]}),"\n",(0,t.jsxs)(n.li,{children:["Now, all the previous instances would have a different ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," than the current and future ones."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Update the ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"})," document if required to have values of the current update input (which would then be used as the new base event)."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"note",children:(0,t.jsxs)(n.p,{children:["Here we're not creating a new ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"})," document, just updating the existing one. i.e. For one recurring event, there would only be one ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"}),", which would connect all the instances, even accross different recurrence rules."]})}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"deleting-recurring-events",children:"Deleting recurring events"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Deleting this instance only / deleting an exception instance (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/deleteEventHelpers/deleteSingleEvent.ts",children:"deleteSingleEvent.ts"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Make a regular deletion."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Deleting all instances / this and future instances (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/deleteEventHelpers/deleteRecurringEventInstances.ts",children:"deleteRecurringEventInstances.ts"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"For deleting all instances:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Delete all the recurring instances with the current ",(0,t.jsx)(n.code,{children:"recurrenceRuleId"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["If this was the latest ",(0,t.jsx)(n.code,{children:"RecurrenceRule"}),", and there exist one or more ",(0,t.jsx)(n.code,{children:"RecurrenceRule"}),"s with the same ",(0,t.jsx)(n.code,{children:"baseRecurringEventId"}),", find the last one of them (i.e. one before the current ",(0,t.jsx)(n.code,{children:"RecurrenceRule"}),") and update the ",(0,t.jsx)(n.code,{children:"endDate"})," of the ",(0,t.jsx)(n.code,{children:"baseRecurringEvent"})," to be that recurrence rule's ",(0,t.jsx)(n.code,{children:"recurrenceEndDate"}),"."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:"For this and future instances:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Find the event instance that was created previously to the current instance with the current ",(0,t.jsx)(n.code,{children:"recurrenceRuleId"}),", set the ",(0,t.jsx)(n.code,{children:"latestInstanceDate"})," and the ",(0,t.jsx)(n.code,{children:"recurrenceEndDate"})," of the ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," to this instance's ",(0,t.jsx)(n.code,{children:"startDate"}),". Update the ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"})," accordingly if the current ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," is the latest (i.e. modifying the ",(0,t.jsx)(n.code,{children:"endDate"})," of ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"})," to this latestInstance's ",(0,t.jsx)(n.code,{children:"startDate"}),")."]}),"\n",(0,t.jsxs)(n.li,{children:["Delete all the recurring instances with the same ",(0,t.jsx)(n.code,{children:"recurrenceRuleId"})," as the current instance, starting from the current date."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsxs)(n.admonition,{type:"note",children:[(0,t.jsxs)(n.p,{children:["Updates would only be done on the ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"})," if bulk operations being are done on the instances following the latest ",(0,t.jsx)(n.code,{children:"RecurrenceRule"}),", because we want to generate new instances (during queries) based on the ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"}),"."]}),(0,t.jsx)(n.p,{children:"How do we ensure that?"}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["By adding a check, of end dates. i.e. we would only modify the ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"})," if its ",(0,t.jsx)(n.code,{children:"endDate"})," matches the ",(0,t.jsx)(n.code,{children:"recurrenceEndDate"})," of the current ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," (",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/updateEventHelpers/shouldUpdateBaseRecurringEvent.ts",children:"shouldUpdateBaseRecurringEvent.ts"})}),")."]}),"\n"]})]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"querying-events",children:"Querying events"}),"\n",(0,t.jsx)(n.p,{children:"In the query, we would add a function for generating recurring event instances, and then query all the events and return them. Here's the two step process:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Generate recurring event instances (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/helpers/event/createEventHelpers/createRecurringEventInstancesDuringQuery.ts",children:"createRecurringEventInstancesDuringQuery.ts"}),"):"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Fix a ",(0,t.jsx)(n.code,{children:"queryUptoDate"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Find all the ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," documents with the ",(0,t.jsx)(n.code,{children:"latestInstanceDate"})," less than ",(0,t.jsx)(n.code,{children:"queryUptoDate"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["For every recurrenceRule document queried:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Find the ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Generate new recurring instance dates after the ",(0,t.jsx)(n.code,{children:"latestInstanceDate"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Account for the number of existing instances following that recurrence pattern and how many more to generate based on the ",(0,t.jsx)(n.code,{children:"RecurrenceRule"}),"'s ",(0,t.jsx)(n.code,{children:"count"})," (if specified)."]}),"\n",(0,t.jsxs)(n.li,{children:["Update the ",(0,t.jsx)(n.code,{children:"latestInstanceDate"})," of the ",(0,t.jsx)(n.code,{children:"RecurrenceRule"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["Generate more instances based on the ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:["Query events according to the inputs (",(0,t.jsx)(n.code,{children:"where"})," and ",(0,t.jsx)(n.code,{children:"sort"}),") and return them (",(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/blob/develop/src/resolvers/Query/eventsByOrganizationConnection.ts",children:"eventsByOrganizationConnection.ts"}),")."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"handling-exception-instances",children:"Handling exception instances"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["With this approach, we don't have to worry about the single instances that have been updated/deleted, because the new instances are to be generated with ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["However, if a bulk operation is made (changing the ",(0,t.jsx)(n.code,{children:"RecurrenceRule"}),", or other event specific parameters), then every instance conforming to the current ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," is affected, even the ones that were edited seperately in single instance updates (their dates might have been changed, attendees list might have been modified, etc.), because they still follow that ",(0,t.jsx)(n.code,{children:"RecurrenceRule"}),". i.e. the ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," wins in the end. Same with deletion, all the events conforming to a ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," are deleted on a bulk delete operation."]}),"\n",(0,t.jsxs)(n.li,{children:["If we want to exclude a certain instance from such operations, we could add the ",(0,t.jsx)(n.code,{children:"isRecurringEventException: true"})," for that instance. By doing that, we could make it completely independent (like a normal event), so that it won't be affected by the bulk operations. If we want it to conform to the rrule again, we could just set the ",(0,t.jsx)(n.code,{children:"isRecurringEventException: false"}),"."]}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"historical-records",children:"Historical Records"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"BaseRecurringEvent"}),", aside from being used as the base event to create new instances, also connects all the instances, even if their ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," are different."]}),"\n",(0,t.jsx)(n.li,{children:"Which means we could also use it to track the historical records for a recurring event, accross all the instances, no matter what recurrence pattern it followed at any point."}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h2,{id:"references",children:"References"}),"\n",(0,t.jsx)(n.h3,{id:"rrule",children:"rrule"}),"\n",(0,t.jsxs)(n.p,{children:["The library we're using that automatically generate the dates of recurrence given a ",(0,t.jsx)(n.code,{children:"RecurrenceRule"}),". ",(0,t.jsx)("br",{}),"\nOfficial repo: ",(0,t.jsx)(n.a,{href:"https://github.com/jkbrzt/rrule",children:(0,t.jsx)(n.code,{children:"rrule"})})]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"recurrencerule",children:"RecurrenceRule"}),"\n",(0,t.jsx)(n.p,{children:"A document containing the properties that represents the recurrence rule followed by a recurring event.:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'  interface InterfaceRecurrenceRule {\n    recurrenceStartDate: Date\n    recurrenceEndDate: Date\n    recurrenceRuleString: string\n    frequency: ["DAILY", "WEEKLY", "MONTHLY", "YEARLY"]\n    weekdays: ["MONDAY", ... , "SUNDAY"]\n    interval: number\n    count: number\n    weekDayOccurenceInMonth: number\n    latestInstanceDate: Date\n    baseRecurringEventId: ObjectId\n    //...other fields\n  }\n'})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"recurrenceStartDate"}),": the start of recurrence."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"recurrenceEndDate"}),": the end of recurrence."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"recurrenceRuleString"}),": an ",(0,t.jsx)(n.code,{children:"rrule"})," string that would be used to generate an ",(0,t.jsx)(n.code,{children:"rrule"})," object, from which we would generate the recurrence dates."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"frequency"}),": Frequency of recurrence."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"weekDays"}),": The days of the week at which the instances would be scheduled."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"interval"}),": Interval of recurrence, i.e every day, every other day, every 5th day, etc."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"count"}),": The number of instances following that recurrence rule."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"weekDayOccurenceInMonth"}),": The occurence of weekDay in month, i.e whether it's the first Monday, third Monday, or last Monday. It is to be used with Monthly frequency, and a weekDay, e.g.:","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["for ",(0,t.jsx)(n.code,{children:"frequency: MONTHLY"})," and ",(0,t.jsx)(n.code,{children:'weekDays: ["MONDAY"]'}),":","\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["if ",(0,t.jsx)(n.code,{children:"weekDayOccurenceInMonth:2"}),", it would mean that the recurring event occurs every ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Second Monday"})})," every month."]}),"\n",(0,t.jsxs)(n.li,{children:["if ",(0,t.jsx)(n.code,{children:"weekDayOccurenceInMonth:-1"}),", it would mean every ",(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Last Monday"})})," every month."]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"latestInstanceDate"}),": the ",(0,t.jsx)(n.code,{children:"startDate"})," of the latest instances generated."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"baseRecurringEventId"}),": The ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"})," for that recurring event."]}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"baserecurringevent",children:"BaseRecurringEvent"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"A special type of event, that connects all the instances of a recurring event, even across different recurrence patterns, which is useful for tracking the historical records of a recurring event."}),"\n",(0,t.jsxs)(n.li,{children:["It is also used as the base event to generate new recurring event instances during queries (As we can't just use the latest instance, which could be an ",(0,t.jsx)(n.code,{children:"exception"})," instance). ",(0,t.jsx)("br",{}),"\nThere would be a flag in the event interface indicating whether it's a ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"}),":"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"  interface InterfaceEvent {\n    //...existing event fields\n    isBaseRecurringEvent: true\n    startDate: Date // the start of recurrence\n    endDate: Date // the `recurrenceEndDate` of the latest recurrence rule\n  }\n"})}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"recurring-event-instance",children:"Recurring Event Instance"}),"\n",(0,t.jsx)(n.p,{children:"Every instance of a recurring event would have these fields:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"  interface InterfaceEvent {\n    //...existing event fields\n    startDate: Date\n    endDate: Date\n    isBaseRecurringEvent: false\n    recurrenceRuleId: ObjectId\n    baseRecurringEvent: ObjectId\n  }\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"startDate"}),": The start date of the event instance."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"endDate"}),": The end date of the event instance."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"isBaseRecurringEvent"}),": The instance itself would not be the base recurring event."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"recurrenceRuleId"}),": Representing the ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," followed by the recurring event."]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"baseRecurringEventId"}),": Representing the ",(0,t.jsx)(n.code,{children:"BaseRecurringEvent"})," for that recurring event."]}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)(n.h3,{id:"recurring-event-exception-instance",children:"Recurring Event Exception Instance"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The bulk operations on a recurring event (",(0,t.jsx)(n.code,{children:"update"}),"/",(0,t.jsx)(n.code,{children:"delete"})," multiple instances) would not affect an ",(0,t.jsx)(n.code,{children:"exception"})," instance."]}),"\n",(0,t.jsx)(n.li,{children:"There would be a flag to mark an exception instance:"}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"  interface InterfaceEvent {\n    //...existing event fields\n    isRecurringEventException: true\n  }\n"})}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"With this flag, a recurring event instance could be turned into an independent non-recurring event."}),"\n",(0,t.jsxs)(n.li,{children:["Changing this field to ",(0,t.jsx)(n.code,{children:"false"})," would again make the instance conform to the ",(0,t.jsx)(n.code,{children:"RecurrenceRule"})," (i.e. it would not be an exception anymore)."]}),"\n"]}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsx)("hr",{}),"\n",(0,t.jsx)("br",{}),"\n",(0,t.jsxs)(n.p,{children:["That explains the approach we're following for ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"creation and management of recurring events"})}),"."]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"The functionalities have been implemented. Check out these parent issues:"})})}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-api/issues/1583",children:"Recurring Events Api"})}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.a,{href:"https://github.com/PalisadoesFoundation/talawa-admin/issues/1643",children:"Recurring Events Admin"})," ",(0,t.jsx)("br",{})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"Go through these and their associated issues and PRs for more details."})})}),"\n",(0,t.jsxs)(n.p,{children:["Last updated on ",(0,t.jsx)(n.em,{children:(0,t.jsx)(n.strong,{children:"April 20, 2024"})})]})]})}function o(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},11151:(e,n,r)=>{r.d(n,{Z:()=>l,a:()=>c});var t=r(67294);const s={},i=t.createContext(s);function c(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:c(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);